//! Periodic task execution and cancellation utilities.
//!
//! This module provides the [`PeriodicTask`] struct for executing asynchronous tasks
//! at fixed intervals. Each task is generated from a closure that produces a future,
//! which is then polled to completion. Once a future completes, the task generates
//! the next future and waits for the specified interval before executing again.
//!
//! It also provides the [`Cancellation`] handle, which can be used to stop
//! the periodic execution. Two types of cancellation are supported:
//! - **Hard cancellation**, which attempts to stop execution immediately.
//! - **Soft cancellation**, which waits for the currently running future to
//!   complete before stopping.
//!
//! Periodic tasks must be manually spawned onto an executor to begin running.

use std::{
    pin::Pin,
    sync::{
        Arc,
        atomic::{AtomicBool, Ordering},
    },
    time::{Duration, Instant},
};

use crate::{Id, timing::schedule::Periodic};

use pin_project_lite::pin_project;

pin_project! {
    /// A future that repeatedly executes a task at a fixed interval until canceled.
    ///
    /// `PeriodicTask` is created and configured with a specified time interval and
    /// an asynchronous task to execute periodically. It can be spawned onto any
    /// executor and will continue running at the given interval until canceled.
    ///
    /// This is useful for maintenance routines, polling tasks, or any recurring async logic.
    ///
    /// To stop a running `PeriodicTask`, use the associated `Cancellation` handle
    /// returned when creating it.
    ///
    /// # Examples
    /// ```no_run
    /// use asyncron::periodic::PeriodicTask;
    /// use std::time::Duration;
    /// use tokio::time::sleep;
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     // Create a new periodic task that prints a message every second.
    ///     let (task, cancellation) = PeriodicTask::new(
    ///         "heartbeat",
    ///         || async {
    ///             println!("Tick!");
    ///         },
    ///         Duration::from_secs(1),
    ///     );
    ///
    ///     // Spawn the periodic task onto the Tokio runtime.
    ///     tokio::spawn(task);
    ///
    ///     // Let it run 7 seconds more, then cancel it.
    ///     sleep(Duration::from_secs(7)).await;
    ///     cancellation.cancel();
    /// }
    /// ```
    /// `Timeout` can be used to stop periodic execution too:
    /// ```no_run
    /// use asyncron::{periodic::PeriodicTask, task_ext::TaskExt};
    /// use std::time::Duration;
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     // Create a new periodic task that prints a message every second.
    ///     let (task, _) = PeriodicTask::new(
    ///         "heartbeat",
    ///         || async {
    ///             println!("Tick!");
    ///         },
    ///         Duration::from_secs(1),
    ///     );
    ///
    ///     // `Timeout` can be used to stop the periodic execution.
    ///     let task = task.timeout(Duration::from_secs(7));
    ///
    ///     // `PeriodicTask` will be timed out in 7 seconds.
    ///     task.await;
    /// }
    /// ```
    #[must_use = "futures do nothing unless polled or .awaited"]
    pub struct PeriodicTask<TaskId: Id, G, F>
    where
        F: Future,
        G: FnMut() -> F,
    {
        id: TaskId,
        future: G,
        current: Option<Pin<Box<F>>>,
        next_run: Instant,  // When should it execute next?
        interval: Duration,
        delay: Pin<Box<Periodic>>,
        cancellation: Arc<AtomicBool>,  // Immediate cancellation flag
        delayed_cancel: Arc<AtomicBool>, // Delayed cancellation flag
        cb: Option<Box<dyn FnMut(&F::Output) + Send + Sync>>
    }
}

impl<TaskId: Id, G, F> PeriodicTask<TaskId, G, F>
where
    F: Future,
    G: FnMut() -> F,
{
    /// Creates a new `PeriodicTask` that repeatedly executes a future at fixed intervals.
    ///
    /// A new future is generated by the provided closure only after the previous one
    /// completes. Future runs to completion, after which the next one is created and
    /// polled after the specified `interval`.
    ///
    /// If the future `F` returns a value, that value must implement the `Default`
    /// trait to allow the periodic task to return a default value when cancelled.
    ///
    /// Returns the `PeriodicTask` and the corresponding `Cancellation` handle used
    /// to stop its execution.
    pub fn new(id: TaskId, future: G, interval: Duration) -> (Self, Cancellation) {
        let next_run = Instant::now() + interval;
        let delay = Box::pin(Periodic::new(interval));
        let cancellation = Cancellation::new();

        let periodic_task = Self {
            id,
            future,
            current: None,
            next_run,
            interval,
            delay,
            cancellation: Arc::clone(&cancellation.cancelled),
            delayed_cancel: Arc::clone(&cancellation.delayed_cancel),
            cb: None,
        };
        (periodic_task, cancellation)
    }

    /// Registers a callback to be invoked after each iteration of the periodic task completes.
    ///
    /// The provided callback is called with a reference to the result produced by
    /// the future returned from the closure passed to [`PeriodicTask::new`]. This
    /// allows observing or reacting to each result without affecting task execution.
    pub fn on_result(
        &mut self,
        callback: impl FnMut(&F::Output) + Send + Sync + 'static,
    ) -> &mut Self {
        self.cb = Some(Box::new(callback));
        self
    }
}

impl<TaskId: Id, G, F> Future for PeriodicTask<TaskId, G, F>
where
    F: Future + Send + 'static,
    G: FnMut() -> F,
    F::Output: Default,
{
    type Output = F::Output;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        if self.cancellation.load(Ordering::Relaxed) {
            return std::task::Poll::Ready(F::Output::default());
        }

        let this = self.project();
        let future1 = this.future;
        let mut future = match this.current.take() {
            Some(f) => f,
            None => {
                // First time we are polling, so we need to create a new future.
                Box::pin(future1())
            }
        };

        let mut wait1 = this.delay.as_mut();
        loop {
            wait1.reset_due(*this.interval);

            // Check if the next run time has passed.
            if Instant::now() >= *this.next_run {
                if let std::task::Poll::Ready(result) = future.as_mut().poll(cx) {
                    if let Some(cb) = this.cb {
                        cb(&result);
                    }
                    if this.delayed_cancel.load(Ordering::Relaxed) {
                        return std::task::Poll::Ready(result);
                    }
                    // Move the next run time forward by the interval.
                    *this.next_run = Instant::now() + *this.interval;

                    // Create a new future for the next run.
                    future = Box::pin(future1());
                    continue;
                }
                // If the future is not ready, we need to store it so that
                // state machine can be resumed later.
                *this.current = Some(future);
                return std::task::Poll::Pending;
            }
            // New future is not ready yet, so we need to wait for the delay.
            // Store it in the current field so that we can resume it later.
            *this.current = Some(future);
            let _ = std::pin::pin!(wait1.as_mut()).poll(cx);
            return std::task::Poll::Pending;
        }
    }
}

/// A handle used to cancel the execution of a [`PeriodicTask`].
///
/// This is returned by [`PeriodicTask::new`] and allows external control over the
/// taskâ€™s lifecycle. It supports both soft and hard cancellation:
///
/// - **Soft cancellation**: Waits for the currently running future to complete
///   before stopping further execution.
/// - **Hard cancellation**: Attempts to abruptly stop execution, even if a future
///   is currently running.
///
/// Use soft cancellation when graceful shutdown is desired, and hard cancellation
/// when an immediate stop is necessary.
#[derive(Clone)]
pub struct Cancellation {
    cancelled: Arc<AtomicBool>,      // Immediate cancellation flag
    delayed_cancel: Arc<AtomicBool>, // Delayed cancellation flag
}

impl Cancellation {
    fn new() -> Self {
        Self {
            cancelled: Arc::new(AtomicBool::new(false)),
            delayed_cancel: Arc::new(AtomicBool::new(false)),
        }
    }

    /// Immediately cancels the associated [`PeriodicTask`], attempting to stop it
    /// even if a future is currently running.
    ///
    /// This is a *hard* cancellation: it does not wait for the currently running
    /// future to complete, and may interrupt execution depending on timing.
    ///
    /// # Example
    /// ```no_run
    /// use asyncron::periodic::PeriodicTask;
    /// use std::time::Duration;
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     let (task, cancel) = PeriodicTask::new(
    ///         42,
    ///         || async {
    ///             // Simulate long work.
    ///             println!("Start tick");
    ///             tokio::time::sleep(Duration::from_secs(5)).await;
    ///             println!("End tick");
    ///         },
    ///         Duration::from_secs(1)
    ///     );
    ///
    ///     tokio::spawn(task);
    ///
    ///     // Cancel shortly after the first tick starts.
    ///     tokio::spawn(async move {
    ///         tokio::time::sleep(Duration::from_millis(500)).await;
    ///         cancel.cancel();
    ///     });
    ///
    ///     // Give it some time before the program exits.
    ///     tokio::time::sleep(Duration::from_secs(9)).await;
    /// }
    /// ```
    pub fn cancel(&self) {
        self.cancelled.store(true, Ordering::Relaxed);
    }

    /// Requests soft cancellation of the periodic task.
    ///
    /// This prevents the task from starting another iteration once the current
    /// future completes. If no future is currently running, the task will be
    /// canceled immediately before generating the next one.
    ///
    /// Unlike [`cancel`](Self::cancel), this method allows the currently running
    /// future to complete normally before stopping further execution. No new futures
    /// will be scheduled after the ongoing one finishes.
    ///
    /// # Example
    /// ```no_run
    /// use asyncron::periodic::PeriodicTask;
    /// use std::time::Duration;
    /// use tokio::time::sleep;
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     let (task, cancel) = PeriodicTask::new(
    ///         42,
    ///         || async {
    ///             // Simulate long work.
    ///             println!("Start tick");
    ///             sleep(Duration::from_secs(5)).await;
    ///             println!("End tick");
    ///         },
    ///         Duration::from_millis(100),
    ///     );
    ///
    ///     tokio::spawn(task);
    ///
    ///     // Let the task run for a bit.
    ///     sleep(Duration::from_millis(1500)).await;
    ///
    ///     // Request a soft cancel: will stop after current iteration completes.
    ///     cancel.cancel_after_ready();
    ///
    ///     // Wait long enough to observe soft cancellation.
    ///     sleep(Duration::from_secs(7)).await;
    /// }
    /// ```
    pub fn cancel_after_ready(&self) {
        self.delayed_cancel.store(true, Ordering::Relaxed);
    }

    /// Returns `true` if cancellation has been requested.
    #[must_use]
    pub fn is_cancelled(&self) -> bool {
        self.cancelled.load(Ordering::Relaxed)
    }
}
